---
title: オブジェクトを移動させるには
---
# オブジェクトを移動させるには

オブジェクトの移動は、どんなゲームであってもそのゲームの肝になる部分です。この移動には、次の要素を含みます。

* 画面上を動くキャラクター：プレイヤー、ノンプレイヤーキャラ（NPC）、車両、宇宙船など
* アニメーションするアイテム：弾丸、レーザー、障害物、背景など
* アニメーションするインタフェース：ボタン、カーソル、残りライフ数など

状況が違えば、必要な解決法も変わります。このページでは、GDevelop で使える解決法について説明します。

GDevelop でオブジェクトの位置を変更するには 3 種類のやり方があります。

* アクションを使って X 座標と Y 座標を変更する
* オブジェクトにフォースを加える（どのオブジェクトにも使えます）
* ビヘイビアを使う（内部的には座標を変更するかフォースを使っています）

## 動かさない：直接オブジェクトの位置を変更する

時にはオブジェクトを徐々に移動したりアニメーションさせる代わりに、オブジェクトの位置をパッと一瞬で変更したいことがあります。そんなときは、アクションを使ってオブジェクトの位置（X 座標と Y 座標）を変更します。

![](/gdevelop5/tutorials/set-object-position.png)

## 他のオブジェクトの動きをそのまま真似る：式でオブジェクトの位置を変更する

あるオブジェクトに他のオブジェクトと同じ動きをさせる、別の言い方をすると相対位置を固定するには、アクションを使ってオブジェクトの位置を変更します。ただし X 座標と Y 座標の値を式に計算させるのです。

これはプレイヤーにくっついて動く**隠しオブジェクト**があって、それを動き回るプレイヤーの頭上に「貼り付け」ておきたいというような場合にぴったりです。たとえば宇宙船のスプライトとパーティクルエミッターをセットで動かす用途などが当てはまります。

下図はプラットフォーマーでプレイヤーオブジェクトの位置を設定する例です。

![](/gdevelop5/tutorials/follow-object-set-position.png)

!!! tip

    `Object.Angle()` 式を使うと、他のオブジェクトと同じ角度に変更することもできます。

## カーソルとして動かす：「MouseX()」と「MouseY()」で位置を変更する

オブジェクトをカーソルとして動かしたいですか？`MouseX()` の値を X 軸に、`MouseY()` の値を Y 軸に指定してオブジェクトの位置を変更してください。

![](/gdevelop5/tutorials/cursor-set-position.png)

!!! note

    「カーソル」として使うオブジェクトは、Z オーダーを他のどれよりも上にするか、または他とレイヤーを分けてしまうといいでしょう。後者の場合は、`MouseX` と `MouseY` の引数にレイヤー名を渡します。たとえばレイヤー名が「user interface」であれば、`MouseX("user interface")`、`MouseY("user interface")` とします。

## 画面上のオブジェクトを動かす：フォースを使う

オブジェクトを動かす一番簡単な方法は、**フォース**を使うことです。

フォースには[basic game making concepts](/ja/gdevelop5/tutorials/basic-game-making-concepts)のページでもふれています。たとえるなら、フォースはオブジェクトを押しのける架空の矢です（「ベクター」とも呼ばれます）。矢が長ければ、オブジェクトは速く動きます。フォースはまた*瞬間的*にも*永続的*にもなります。

* **瞬間的**なフォースはオブジェクトを「一回だけ」動かします（フォースはアクションが実行中のあいだだけオブジェクトに作用します）。

  ![](/gdevelop5/tutorials/instant-force-example.png)

* **永続的**なフォースはオブジェクトをずっと押し続けます。これを止めるには、オブジェクトを停止するアクションを実行する必要があります。停止アクションはオブジェクトに作用しているフォースをすべてクリアするため、結果的にオブジェクトは停止します（何かのビヘイビアが使われていたり、他のイベントによって位置が変更されたら、それはまた別の話です）。たとえば次の 2 つのイベントは、プラットフォームを 2 つのマーカーのあいだで移動し続けます。

![](/gdevelop5/tutorials/animate-platform-permanent-forces.png)

どちらの種類のフォースを使えばいいのかよく分からないときは、次のアドバイスを参考にしてください。

> 瞬間的なフォースは、条件を一瞬で判定する場合に使うといいでしょう。キーが押されたり、オブジェクトがタッチされたりカーソルがホバーしたり、そういう場合です。それに対して永続的なフォースは、最初に一度だけ条件判定するとその状態が一定時間続くような場合に使います（たとえば衝突のような）。

永続的なフォースは音楽の再生に似ています。一回開始すれば、しばらくはそれでじゅうぶんです。

!!! note

    技術的なことをいえば、フォースが 1 フレームのあいだにオブジェクトを動かす量は、フォースの長さに前回のフレームからの経過時間を乗じた値です。別の言い方をすると、フォースの速度は 1 秒間に移動するピクセル数と同じです。フォースを使う上で、この仕組みを理解する必要は別にありません。ただ残念な結果にしないために、適切な種類のフォース（瞬間的か永続的か）を使うように意識してください。

## プラットフォーマー ビヘイビア

プラットフォーマー型のゲームでキャラクターを動かすのでしたら、[プラットフォーマー ビヘイビア](/ja/gdevelop5/behaviors/platformer)がおすすめです。これを使うと GDevelop がプラットフォーマー用のエンジンに早変わりします。

* プラットフォーム上で操作するプレイヤーやオブジェクトには、**プラットフォーマーキャラクター**ビヘイビアを追加します。
* 足場に使うプラットフォームとなるオブジェクトには**プラットフォーム**ビヘイビアを追加します。

ビヘイビアのプロパティを編集してイベントを使うと、プラットフォーマーのキャラクターの動き方をカスタマイズできます。

## 物理エンジン

箱が落下したり、床に当たって跳ね返ったり、そんなふうにオブジェクトを物理法則にしたがって動かしたければ、[物理エンジンビヘイビア](/ja/gdevelop5/behaviors/physics2)を検討してみてください。

物理エンジンはフォースやプラットフォームビヘイビアのようなビヘイビアよりも、*もっと複雑*です。このビヘイビアを使う場合は、すべてのオブジェクトに対して追加することをお勧めします。

!!! warning

    物理エンジンビヘイビアが追加されたオブジェクトは、物理エンジンによって動きます。これらのオブジェクトを物理エンジンビヘイビアに属さないフォースや他のアクションで動かそうとすると、おそらく物理エンジンがリアルなシミュレーションをおこなうことに支障をきたして、何らかの「グリッチ」が発生するでしょう。

## サイン（または楕円）移動ビヘイビア

サイン（または楕円）移動ビヘイビアは[拡張機能としてインストールする](/ja/gdevelop5/extensions/search)ビヘイビアです。

このビヘイビアをオブジェクトに追加すると、移動の振幅を X 軸と Y 軸それぞれについて設定できるようになります。オブジェクトを円状や楕円状に旋回し続けるようにするときに便利です。

## フォースとバウンスビヘイビア

**バウンスビヘイビア**[拡張機能としてインストールする](/ja/gdevelop5/extensions/search)ビヘイビアです。

このビヘイビアをオブジェクトに追加すると、オブジェクトが障害物と衝突しているかどうかをチェックするための条件が追加されます。この条件に対応するアクションで、オブジェクトが障害物から跳ね返る動作を設定します。

!!! note

    このビヘイビアは、フォースと併用できます。まずオブジェクトにフォースを加えて移動します。次にこのビヘイビアとアクションを追加して、衝突時の跳ね返りを表現します。

## 経路探索：障害物を迂回する経路を探し、それをたどる

[経路探索ビヘイビア](/ja/gdevelop5/behaviors/pathfinding)は、オブジェクトの現在位置と目的の位置を結ぶ経路を計算する高度なアルゴリズムです。経路は、障害物に設定された他のオブジェクトを避ける最短経路になります。

これはシミュレーションゲームはもちろんのこと、キャラクターやユニットが障害物を回避しながら個別に移動する要素のあるどんなゲームにも役立ちます。

## アンカービヘイビア：オブジェクトを画面に固定してウィンドウのリサイズに影響されない

[アンカービヘイビア](/ja/gdevelop5/behaviors/anchor)を使うと、オブジェクトをウィンドウ境界（上下左右）に固定できます。ゲームウィンドウをリサイズしたり解像度を変更した場合は、オブジェクトの配置が自動調整され、ウィンドウ境界からの距離を変更前と同じ距離に保ちます。

これはモバイルゲームの**ビジュアルコントロール**や、HUD に代表される**ユーザーインターフェイス**の作成で活躍します。