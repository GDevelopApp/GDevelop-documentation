---
title: 変数
---
# 変数

GDevelop では、数値やテキストのようなデータを一時的に格納するために、_変数_を使うことができます。たとえばプレイヤーの名前、体力、スコアなどを変数に記憶しておけます。

!!! note

    セーブデータのような、一時的ではないデータを格納する方法については、[storage](/ja/gdevelop5/all-features/storage)を参照してください。

## データ型

変数は_データ型_というものを持ちます。変数のデータ型は、変数が保持するデータの種類を表したものです。

GDevelop の変数には、次のデータ型があります。

- 数値
- テキスト
- 真偽値
- 構造体
- 配列

（訳注：直接値が格納される、数値、テキスト、真偽値の変数を「プリミティブ変数」といい、他のデータ型を格納できる構造体と配列を「コレクション変数」といいます）

### 数値
データ型が*数値*の変数には、`0` や `100`、`-10` といった数値を格納できます。このデータ型を持つ変数を使って、掛け算や割り算といった数学的な計算ができます。

### テキスト
データ型が*テキスト*の変数には、`こんにちは世界` といったテキストを格納できます。プログラミング言語では、このデータ型のことをよく_文字列_と呼んでいます。このドキュメントでも*テキスト*と言ったり*文字列*と言ったりすることがありますが、同じ意味です。

### 真偽値
データ型が*真偽値*の変数には、最も単純な形式の情報が含まれています。
真（true）または偽（false）のどちらかです。
これは簡単に切り替えることができるので便利です。

#### 真偽値を追加する
レンチアイコン →「Primitive types」（プリミティブ型）→「真偽値に変換」をクリックすると、変数の型を真偽値に変換できます。
![](/gdevelop5/tutorials/toggles1.png)

#### 真偽値の変更
真偽値の状態を変更する方法は2つあります。

**真偽値を変更します**
真偽値を真（true）または偽（false）に設定できます。

**真偽値を切り替えます**
状態を切り替えることができます。
値が真（true）の場合、偽（false）に変更され、その逆も同様です。

#### 真偽値の確認
**真偽値を比較します**
真偽値が真（true）か偽（false）かを確認できます。
真偽値を別の値、テキストまたは真偽値と比較するには、**二つの文字列を比べる**を使用できます。

### 構造体

構造体変数には、複数の変数を格納することができます。
たとえば、単純な構造では「Hello」という名前の変数と、「World」という名前の変数を格納できます。
このデータ型を使用して、関連する変数をひとつの変数にまとめることができます。
プログラミング言語では、このデータ型はオブジェクト、マップ、ハッシュ、または辞書と呼ばれることがよくあります。

### 配列
配列変数は、プログラミング言語ではリストとも呼ばれ、変数のリストのようなものです。
配列内の各変数には、配列内での位置を示す番号があります。番号は 0 から始まり、配列の長さに応じて大きくなります。

!!! danger

    文字列を配列変数の番号として使用しないでください。その場合、0番目の変数が返されます。

#### 子変数へのアクセス

コレクション変数が内部に保持する変数のことを_子変数_と呼びます。（訳注：「子要素」あるいは単に「要素」と呼ぶこともありますが、同じ意味です）子変数の値にアクセスするには、[式](/ja/gdevelop5/all-features/expressions)の中で次の構文を使います。山括弧内の値は、実際の変数名に置き換えてください。

```
<親変数>.<子変数>
```
このような構造になっているとします。
![](/gdevelop5/all-features/variable_strucure_with_values.png)
値 "123" を得るには、次のような式を書きます。
```
GlobalVariable(players.player1.level1score)
```
!!! tip

    構造体の場合は、`<子変数>`は子変数の名前で、配列の場合は子変数の番号になります。配列の場合、番号として機能するのは数字のみであることに注意してください。

子変数が存在しない場合は、GDevelop がそれを自動的に作成します。

!!! note

    コレクション変数には、どんなデータ型の変数でも含むことができます。これによって、複雑な構成のデータを一つの変数に保持することが可能になります。ただしデータの管理が難しくなるので、慎重に使ってください。

#### 子変数への動的アクセス

式を使うと、子変数に動的にアクセスできます。

たとえばプレイヤーのスコアを表す構造体 `PlayerScore` があって、レベルごとのスコアを子変数 `Level1`、`Level2`、`Level3` に格納している状態を想像してください。現在のレベル番号が `CurrentLevel` という変数に入っていて、そのレベルのプレイヤーのスコアを取得したいものとします。この場合は、次の構文でスコアにアクセスできます。

```
PlayerScore[“Level”+ToString(Variable(CurrentLevel))]
```

## スコープ

変数の_スコープ_は、下記の内容を定義します。

- 変数に対してどこからアクセスできるか
- 変数がどれくらいのあいだメモリー上に存在するか
- 変数の作成に必要な手順は何か

GDevelop には次の 3 つの変数スコープが存在します。

- [グローバル](/ja/gdevelop5/all-features/variables/global-variables)
- [シーン](/ja/gdevelop5/all-features/variables/scene-variables)
- [オブジェクト](/ja/gdevelop5/all-features/variables/object-variables)

各変数スコープの詳細については、リンク先のページを参照してください。

## 変数の名前付け

変数の名前にはドット/ピリオド（.）とカンマ（,）は使えません。また文字で始まる必要があります。
変数名には英数字のみ（a-z, A-Z, 0-9）を使うことをおすすめします。（訳注：仕様上は日本語を使っても問題ありません）

## 宣言しないで変数を使う

作成（宣言）しないで、いきなり変数を使うこともできます。

たとえばアクションや条件の中で存在しない変数を参照した場合、GDevelop はその変数を自動的に既定値で初期化します。既定値はデータ型に応じて次のように決まります。

* 数値変数は値 `0` で初期化される
* テキスト変数は値 `""`（空文字列）で初期化される

事前に作成していない変数を使うことは可能ですが、変数は使う前に明示的に宣言して初期化することをお勧めします。それによって GDevelop が最適化したイベントを生成して、ゲームで使われる変数をきちんと管理することができるようになるからです。

## 変数のデバッグ

ゲームを作っていると、変数の値が予期した値にならないせいで、バグが発生することがあります。もしゲームの何かがうまく動かなくて、その問題に変数が関係している可能性がある場合は、GDevelop のデバッガーが原因究明の役に立つでしょう。

詳細は[debugger](/ja/gdevelop5/interface/debugger)を参照してください。